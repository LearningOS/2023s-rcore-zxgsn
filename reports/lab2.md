### lab2
#### 实现功能总结
1. 重写sys_get_time时，增加了从用户态虚拟地址写入物理地址的功能
2. sys_task_info实现和上一次实验差不多
3. mmap 和 munmap 匿名映射
   mmap函数，封装了一个函数，可以将一段空间添加到memory_set中, 因为实验指导提到调用memory_set的.insert_framed_area函数之前要保证插入的集合无交集，因此额外维护了记录已分配空间的vec变量
   munmap函数，简单地对所有在区间内的页面进行unmap，并将该空间从已分配的记录变量中移除
#### 问答题
1. SV39的页表项的第53位到第10位是物理页号，最低的8位是标志位。标志位的含义：
   V位: 判断页表项是否合法；
   R、W、X位： 分别控制索引到这个页表项的对应虚拟页面是否允许读/写/执行；
   U位：控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；
   G位：用于指示一个页面是否应该被共享；
   A位：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过;
   D位：处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被修改过.
2. (1). 缺页导致的异常： StorePageFault 和 LoadPageFault.
   (2). satp寄存器：保存当前所用的一级页表的物理页.
        sstatus: 存储Trap 发生之前 CPU 处在哪个特权级（S/U）等信息.
        sepc: 当 Trap 是一个异常的时候，记录 Trap 发生之前执行的最后一条指令的地址.
        sscratch: 暂存内核栈地址.
   (3). 一次性加载可以减少从磁盘加载进内存的损耗，同时可以避免一些没有意义的页表的操作.
   (4). 处理 10G 连续的内存页面，对应的 SV39 页表大致占用 20M 内存.
   (5). lazy策略的实现: 只有当页面被访问的时候，才将相应的页面加载进内存。
   当缺页时，触发中断异常，从磁盘上将页面加载进内存.
   (6). 页面失效表现在页表项上是将页表项的V位置为0.
3. (1). 在单页表情况下，不能直接更换页表， 而是更改对应的页表的指针使其指向新的页表.
   (2). 单页表情况下，通过将页表项的U位置为0即可控制用户态无法访问内核页面.
   (3). 单页表的优势：减少在不同页表中切换的开销，同时可以减少不同特权态地址转换的开销.
   (4). 双页表的情况下，在用户态和内核态间的切换需要更换页表，任务执行完或者中断导致任务切换时需要更换页表.
   假设我写一个单页表操作系统，我会在进行任务切换时更换页表.

#### 荣誉准则
1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

    无

2. 本次实验未参考实验指导书以外的其他资料

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。